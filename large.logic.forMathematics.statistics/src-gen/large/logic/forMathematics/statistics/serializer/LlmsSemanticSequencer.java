/*
 * generated by Xtext 2.35.0
 */
package large.logic.forMathematics.statistics.serializer;

import com.google.inject.Inject;
import java.util.Set;
import large.logic.forMathematics.statistics.llms.Ands;
import large.logic.forMathematics.statistics.llms.AritmeticOperation;
import large.logic.forMathematics.statistics.llms.Bodies;
import large.logic.forMathematics.statistics.llms.Booleans;
import large.logic.forMathematics.statistics.llms.CallVariable;
import large.logic.forMathematics.statistics.llms.Divition;
import large.logic.forMathematics.statistics.llms.Doubles;
import large.logic.forMathematics.statistics.llms.Equal;
import large.logic.forMathematics.statistics.llms.Expression;
import large.logic.forMathematics.statistics.llms.Functions;
import large.logic.forMathematics.statistics.llms.GreaterOrEqual;
import large.logic.forMathematics.statistics.llms.GreaterThan;
import large.logic.forMathematics.statistics.llms.LessOrEqual;
import large.logic.forMathematics.statistics.llms.LessThan;
import large.logic.forMathematics.statistics.llms.LlmsPackage;
import large.logic.forMathematics.statistics.llms.Multiplication;
import large.logic.forMathematics.statistics.llms.Names;
import large.logic.forMathematics.statistics.llms.Nands;
import large.logic.forMathematics.statistics.llms.Nors;
import large.logic.forMathematics.statistics.llms.NotEqual;
import large.logic.forMathematics.statistics.llms.Nots;
import large.logic.forMathematics.statistics.llms.Numbers;
import large.logic.forMathematics.statistics.llms.Operations;
import large.logic.forMathematics.statistics.llms.Ors;
import large.logic.forMathematics.statistics.llms.ParametersOutptut;
import large.logic.forMathematics.statistics.llms.Primary;
import large.logic.forMathematics.statistics.llms.Prints;
import large.logic.forMathematics.statistics.llms.Strings;
import large.logic.forMathematics.statistics.llms.Subs;
import large.logic.forMathematics.statistics.llms.Sum;
import large.logic.forMathematics.statistics.llms.Variables;
import large.logic.forMathematics.statistics.llms.callFunction;
import large.logic.forMathematics.statistics.llms.funOutputs;
import large.logic.forMathematics.statistics.llms.varParmArgs;
import large.logic.forMathematics.statistics.services.LlmsGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LlmsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LlmsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LlmsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LlmsPackage.ANDS:
				sequence_Ands(context, (Ands) semanticObject); 
				return; 
			case LlmsPackage.ARITMETIC_OPERATION:
				sequence_AritmeticOperation(context, (AritmeticOperation) semanticObject); 
				return; 
			case LlmsPackage.BODIES:
				sequence_Bodies(context, (Bodies) semanticObject); 
				return; 
			case LlmsPackage.BOOLEANS:
				sequence_Booleans(context, (Booleans) semanticObject); 
				return; 
			case LlmsPackage.CALL_VARIABLE:
				sequence_CallVariable(context, (CallVariable) semanticObject); 
				return; 
			case LlmsPackage.DIVITION:
				sequence_Divition(context, (Divition) semanticObject); 
				return; 
			case LlmsPackage.DOUBLES:
				sequence_Doubles(context, (Doubles) semanticObject); 
				return; 
			case LlmsPackage.EQUAL:
				if (rule == grammarAccess.getConditionalsRule()) {
					sequence_Conditionals_Equal_LogicalParams(context, (Equal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperationRule()
						|| rule == grammarAccess.getLogicalOperationRule()
						|| rule == grammarAccess.getEqualRule()) {
					sequence_Equal(context, (Equal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalParamsRule()) {
					sequence_Equal_LogicalParams(context, (Equal) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case LlmsPackage.FUNCTIONS:
				sequence_Functions(context, (Functions) semanticObject); 
				return; 
			case LlmsPackage.GREATER_OR_EQUAL:
				if (rule == grammarAccess.getConditionalsRule()) {
					sequence_Conditionals_GreaterOrEqual_LogicalParams(context, (GreaterOrEqual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperationRule()
						|| rule == grammarAccess.getLogicalOperationRule()
						|| rule == grammarAccess.getGreaterOrEqualRule()) {
					sequence_GreaterOrEqual(context, (GreaterOrEqual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalParamsRule()) {
					sequence_GreaterOrEqual_LogicalParams(context, (GreaterOrEqual) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.GREATER_THAN:
				if (rule == grammarAccess.getConditionalsRule()) {
					sequence_Conditionals_GreaterThan_LogicalParams(context, (GreaterThan) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperationRule()
						|| rule == grammarAccess.getLogicalOperationRule()
						|| rule == grammarAccess.getGreaterThanRule()) {
					sequence_GreaterThan(context, (GreaterThan) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalParamsRule()) {
					sequence_GreaterThan_LogicalParams(context, (GreaterThan) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.LESS_OR_EQUAL:
				if (rule == grammarAccess.getConditionalsRule()) {
					sequence_Conditionals_LessOrEqual_LogicalParams(context, (LessOrEqual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperationRule()
						|| rule == grammarAccess.getLogicalOperationRule()
						|| rule == grammarAccess.getLessOrEqualRule()) {
					sequence_LessOrEqual(context, (LessOrEqual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalParamsRule()) {
					sequence_LessOrEqual_LogicalParams(context, (LessOrEqual) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.LESS_THAN:
				if (rule == grammarAccess.getConditionalsRule()) {
					sequence_Conditionals_LessThan_LogicalParams(context, (LessThan) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperationRule()
						|| rule == grammarAccess.getLogicalOperationRule()
						|| rule == grammarAccess.getLessThanRule()) {
					sequence_LessThan(context, (LessThan) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalParamsRule()) {
					sequence_LessThan_LogicalParams(context, (LessThan) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case LlmsPackage.NAMES:
				sequence_Names(context, (Names) semanticObject); 
				return; 
			case LlmsPackage.NANDS:
				sequence_Nands(context, (Nands) semanticObject); 
				return; 
			case LlmsPackage.NORS:
				sequence_Nors(context, (Nors) semanticObject); 
				return; 
			case LlmsPackage.NOT_EQUAL:
				if (rule == grammarAccess.getConditionalsRule()) {
					sequence_Conditionals_LogicalParams_NotEqual(context, (NotEqual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalParamsRule()) {
					sequence_LogicalParams_NotEqual(context, (NotEqual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperationRule()
						|| rule == grammarAccess.getLogicalOperationRule()
						|| rule == grammarAccess.getNotEqualRule()) {
					sequence_NotEqual(context, (NotEqual) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.NOTS:
				sequence_Nots(context, (Nots) semanticObject); 
				return; 
			case LlmsPackage.NUMBERS:
				if (rule == grammarAccess.getLoopsRule()) {
					sequence_Loops_Numbers(context, (Numbers) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParmsPrintRule()
						|| rule == grammarAccess.getSumRule()
						|| action == grammarAccess.getSumAccess().getSumLeftAction_1_0()
						|| rule == grammarAccess.getSubsRule()
						|| action == grammarAccess.getSubsAccess().getSubsLeftAction_1_0()
						|| rule == grammarAccess.getDivitionRule()
						|| action == grammarAccess.getDivitionAccess().getDivitionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getDataRule()
						|| rule == grammarAccess.getNumbersRule()) {
					sequence_Numbers(context, (Numbers) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.OPERATIONS:
				sequence_Operations(context, (Operations) semanticObject); 
				return; 
			case LlmsPackage.ORS:
				sequence_Ors(context, (Ors) semanticObject); 
				return; 
			case LlmsPackage.PARAMETERS_OUTPTUT:
				sequence_ParametersOutptut(context, (ParametersOutptut) semanticObject); 
				return; 
			case LlmsPackage.PRIMARY:
				sequence_Primary(context, (Primary) semanticObject); 
				return; 
			case LlmsPackage.PRINTS:
				sequence_Prints(context, (Prints) semanticObject); 
				return; 
			case LlmsPackage.STRINGS:
				sequence_Strings(context, (Strings) semanticObject); 
				return; 
			case LlmsPackage.SUBS:
				sequence_Subs(context, (Subs) semanticObject); 
				return; 
			case LlmsPackage.SUM:
				sequence_Sum(context, (Sum) semanticObject); 
				return; 
			case LlmsPackage.VARIABLES:
				if (rule == grammarAccess.getLoopsRule()) {
					sequence_Loops_Variables(context, (Variables) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariablesRule()) {
					sequence_Variables(context, (Variables) semanticObject); 
					return; 
				}
				else break;
			case LlmsPackage.CALL_FUNCTION:
				sequence_callFunction(context, (callFunction) semanticObject); 
				return; 
			case LlmsPackage.FUN_OUTPUTS:
				sequence_Parametersfunc(context, (funOutputs) semanticObject); 
				return; 
			case LlmsPackage.VAR_PARM_ARGS:
				sequence_varParmArgs(context, (varParmArgs) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Ands
	 *     BooleanFunction returns Ands
	 *     Ands returns Ands
	 *
	 * Constraint:
	 *     primary+=Primary+
	 * </pre>
	 */
	protected void sequence_Ands(ISerializationContext context, Ands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns AritmeticOperation
	 *     AritmeticOperation returns AritmeticOperation
	 *
	 * Constraint:
	 *     sum=Sum
	 * </pre>
	 */
	protected void sequence_AritmeticOperation(ISerializationContext context, AritmeticOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.ARITMETIC_OPERATION__SUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.ARITMETIC_OPERATION__SUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAritmeticOperationAccess().getSumSumParserRuleCall_0(), semanticObject.getSum());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Bodies returns Bodies
	 *
	 * Constraint:
	 *     var+=Variables*
	 * </pre>
	 */
	protected void sequence_Bodies(ISerializationContext context, Bodies semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParmsPrint returns Booleans
	 *     Sum returns Booleans
	 *     Sum.Sum_1_0 returns Booleans
	 *     Subs returns Booleans
	 *     Subs.Subs_1_0 returns Booleans
	 *     Divition returns Booleans
	 *     Divition.Divition_1_0 returns Booleans
	 *     Multiplication returns Booleans
	 *     Multiplication.Multiplication_1_0 returns Booleans
	 *     Primary returns Booleans
	 *     Data returns Booleans
	 *     Booleans returns Booleans
	 *
	 * Constraint:
	 *     value?='true'?
	 * </pre>
	 */
	protected void sequence_Booleans(ISerializationContext context, Booleans semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParmsPrint returns CallVariable
	 *     CallVariable returns CallVariable
	 *
	 * Constraint:
	 *     vars=[Variables|ID]
	 * </pre>
	 */
	protected void sequence_CallVariable(ISerializationContext context, CallVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.CALL_VARIABLE__VARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.CALL_VARIABLE__VARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallVariableAccess().getVarsVariablesIDTerminalRuleCall_0_1(), semanticObject.eGet(LlmsPackage.Literals.CALL_VARIABLE__VARS, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conditionals returns Equal
	 *
	 * Constraint:
	 *     (
	 *         left=Primary 
	 *         right=Primary 
	 *         (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)* 
	 *         body+=Bodies+ 
	 *         (logicParms+=LogicalParams body+=Bodies+)* 
	 *         body+=Bodies+
	 *     )
	 * </pre>
	 */
	protected void sequence_Conditionals_Equal_LogicalParams(ISerializationContext context, Equal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conditionals returns GreaterOrEqual
	 *
	 * Constraint:
	 *     (
	 *         left=Primary 
	 *         right=Primary 
	 *         (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)* 
	 *         body+=Bodies+ 
	 *         (logicParms+=LogicalParams body+=Bodies+)* 
	 *         body+=Bodies+
	 *     )
	 * </pre>
	 */
	protected void sequence_Conditionals_GreaterOrEqual_LogicalParams(ISerializationContext context, GreaterOrEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conditionals returns GreaterThan
	 *
	 * Constraint:
	 *     (
	 *         left=Primary 
	 *         right=Primary 
	 *         (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)* 
	 *         body+=Bodies+ 
	 *         (logicParms+=LogicalParams body+=Bodies+)* 
	 *         body+=Bodies+
	 *     )
	 * </pre>
	 */
	protected void sequence_Conditionals_GreaterThan_LogicalParams(ISerializationContext context, GreaterThan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conditionals returns LessOrEqual
	 *
	 * Constraint:
	 *     (
	 *         left=Primary 
	 *         right=Primary 
	 *         (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)* 
	 *         body+=Bodies+ 
	 *         (logicParms+=LogicalParams body+=Bodies+)* 
	 *         body+=Bodies+
	 *     )
	 * </pre>
	 */
	protected void sequence_Conditionals_LessOrEqual_LogicalParams(ISerializationContext context, LessOrEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conditionals returns LessThan
	 *
	 * Constraint:
	 *     (
	 *         left=Primary 
	 *         right=Primary 
	 *         (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)* 
	 *         body+=Bodies+ 
	 *         (logicParms+=LogicalParams body+=Bodies+)* 
	 *         body+=Bodies+
	 *     )
	 * </pre>
	 */
	protected void sequence_Conditionals_LessThan_LogicalParams(ISerializationContext context, LessThan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conditionals returns NotEqual
	 *
	 * Constraint:
	 *     (
	 *         left=Primary 
	 *         right=Primary 
	 *         (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)* 
	 *         body+=Bodies+ 
	 *         (logicParms+=LogicalParams body+=Bodies+)* 
	 *         body+=Bodies+
	 *     )
	 * </pre>
	 */
	protected void sequence_Conditionals_LogicalParams_NotEqual(ISerializationContext context, NotEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sum returns Divition
	 *     Sum.Sum_1_0 returns Divition
	 *     Subs returns Divition
	 *     Subs.Subs_1_0 returns Divition
	 *     Divition returns Divition
	 *     Divition.Divition_1_0 returns Divition
	 *
	 * Constraint:
	 *     (left=Divition_Divition_1_0 right=Multiplication)
	 * </pre>
	 */
	protected void sequence_Divition(ISerializationContext context, Divition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.DIVITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.DIVITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.DIVITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.DIVITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivitionAccess().getDivitionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivitionAccess().getRightMultiplicationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParmsPrint returns Doubles
	 *     Sum returns Doubles
	 *     Sum.Sum_1_0 returns Doubles
	 *     Subs returns Doubles
	 *     Subs.Subs_1_0 returns Doubles
	 *     Divition returns Doubles
	 *     Divition.Divition_1_0 returns Doubles
	 *     Multiplication returns Doubles
	 *     Multiplication.Multiplication_1_0 returns Doubles
	 *     Primary returns Doubles
	 *     Data returns Doubles
	 *     Doubles returns Doubles
	 *
	 * Constraint:
	 *     value=DOUBLE
	 * </pre>
	 */
	protected void sequence_Doubles(ISerializationContext context, Doubles semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.DOUBLES__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.DOUBLES__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoublesAccess().getValueDOUBLETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Equal
	 *     LogicalOperation returns Equal
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (left=Primary right=Primary)
	 * </pre>
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getLeftPrimaryParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualAccess().getRightPrimaryParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalParams returns Equal
	 *
	 * Constraint:
	 *     (left=Primary right=Primary (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*)
	 * </pre>
	 */
	protected void sequence_Equal_LogicalParams(ISerializationContext context, Equal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     op=Operation
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.EXPRESSION__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getOpOperationParserRuleCall_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Functions returns Functions
	 *
	 * Constraint:
	 *     (output=ParametersOutptut name=Names params=Parametersfunc body=Bodies)
	 * </pre>
	 */
	protected void sequence_Functions(ISerializationContext context, Functions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.FUNCTIONS__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.FUNCTIONS__OUTPUT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.FUNCTIONS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.FUNCTIONS__NAME));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.FUNCTIONS__PARAMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.FUNCTIONS__PARAMS));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.FUNCTIONS__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.FUNCTIONS__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionsAccess().getOutputParametersOutptutParserRuleCall_1_0(), semanticObject.getOutput());
		feeder.accept(grammarAccess.getFunctionsAccess().getNameNamesParserRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionsAccess().getParamsParametersfuncParserRuleCall_4_0(), semanticObject.getParams());
		feeder.accept(grammarAccess.getFunctionsAccess().getBodyBodiesParserRuleCall_7_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns GreaterOrEqual
	 *     LogicalOperation returns GreaterOrEqual
	 *     GreaterOrEqual returns GreaterOrEqual
	 *
	 * Constraint:
	 *     (left=Primary right=Primary)
	 * </pre>
	 */
	protected void sequence_GreaterOrEqual(ISerializationContext context, GreaterOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterOrEqualAccess().getLeftPrimaryParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterOrEqualAccess().getRightPrimaryParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalParams returns GreaterOrEqual
	 *
	 * Constraint:
	 *     (left=Primary right=Primary (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*)
	 * </pre>
	 */
	protected void sequence_GreaterOrEqual_LogicalParams(ISerializationContext context, GreaterOrEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns GreaterThan
	 *     LogicalOperation returns GreaterThan
	 *     GreaterThan returns GreaterThan
	 *
	 * Constraint:
	 *     (left=Primary right=Primary)
	 * </pre>
	 */
	protected void sequence_GreaterThan(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterThanAccess().getLeftPrimaryParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterThanAccess().getRightPrimaryParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalParams returns GreaterThan
	 *
	 * Constraint:
	 *     (left=Primary right=Primary (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*)
	 * </pre>
	 */
	protected void sequence_GreaterThan_LogicalParams(ISerializationContext context, GreaterThan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns LessOrEqual
	 *     LogicalOperation returns LessOrEqual
	 *     LessOrEqual returns LessOrEqual
	 *
	 * Constraint:
	 *     (left=Primary right=Primary)
	 * </pre>
	 */
	protected void sequence_LessOrEqual(ISerializationContext context, LessOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLessOrEqualAccess().getLeftPrimaryParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLessOrEqualAccess().getRightPrimaryParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalParams returns LessOrEqual
	 *
	 * Constraint:
	 *     (left=Primary right=Primary (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*)
	 * </pre>
	 */
	protected void sequence_LessOrEqual_LogicalParams(ISerializationContext context, LessOrEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns LessThan
	 *     LogicalOperation returns LessThan
	 *     LessThan returns LessThan
	 *
	 * Constraint:
	 *     (left=Primary right=Primary)
	 * </pre>
	 */
	protected void sequence_LessThan(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLessThanAccess().getLeftPrimaryParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLessThanAccess().getRightPrimaryParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalParams returns LessThan
	 *
	 * Constraint:
	 *     (left=Primary right=Primary (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*)
	 * </pre>
	 */
	protected void sequence_LessThan_LogicalParams(ISerializationContext context, LessThan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalParams returns NotEqual
	 *
	 * Constraint:
	 *     (left=Primary right=Primary (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*)
	 * </pre>
	 */
	protected void sequence_LogicalParams_NotEqual(ISerializationContext context, NotEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Loops returns Numbers
	 *
	 * Constraint:
	 *     (value=INT number=Numbers body+=Bodies+)
	 * </pre>
	 */
	protected void sequence_Loops_Numbers(ISerializationContext context, Numbers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Loops returns Variables
	 *
	 * Constraint:
	 *     ((typesVars=varParmArgs | typesVars=CallVariable) exp=Expression number=Numbers body+=Bodies+)
	 * </pre>
	 */
	protected void sequence_Loops_Variables(ISerializationContext context, Variables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sum returns Multiplication
	 *     Sum.Sum_1_0 returns Multiplication
	 *     Subs returns Multiplication
	 *     Subs.Subs_1_0 returns Multiplication
	 *     Divition returns Multiplication
	 *     Divition.Divition_1_0 returns Multiplication
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0 returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Names returns Names
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Names(ISerializationContext context, Names semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.NAMES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.NAMES__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamesAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Nands
	 *     BooleanFunction returns Nands
	 *     Nands returns Nands
	 *
	 * Constraint:
	 *     primary+=Primary+
	 * </pre>
	 */
	protected void sequence_Nands(ISerializationContext context, Nands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Nors
	 *     BooleanFunction returns Nors
	 *     Nors returns Nors
	 *
	 * Constraint:
	 *     primary+=Primary+
	 * </pre>
	 */
	protected void sequence_Nors(ISerializationContext context, Nors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns NotEqual
	 *     LogicalOperation returns NotEqual
	 *     NotEqual returns NotEqual
	 *
	 * Constraint:
	 *     (left=Primary right=Primary)
	 * </pre>
	 */
	protected void sequence_NotEqual(ISerializationContext context, NotEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.LOGICAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotEqualAccess().getLeftPrimaryParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNotEqualAccess().getRightPrimaryParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Nots
	 *     BooleanFunction returns Nots
	 *     Nots returns Nots
	 *
	 * Constraint:
	 *     primary+=Primary+
	 * </pre>
	 */
	protected void sequence_Nots(ISerializationContext context, Nots semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParmsPrint returns Numbers
	 *     Sum returns Numbers
	 *     Sum.Sum_1_0 returns Numbers
	 *     Subs returns Numbers
	 *     Subs.Subs_1_0 returns Numbers
	 *     Divition returns Numbers
	 *     Divition.Divition_1_0 returns Numbers
	 *     Multiplication returns Numbers
	 *     Multiplication.Multiplication_1_0 returns Numbers
	 *     Primary returns Numbers
	 *     Data returns Numbers
	 *     Numbers returns Numbers
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Numbers(ISerializationContext context, Numbers semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.NUMBERS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.NUMBERS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumbersAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operations returns Operations
	 *
	 * Constraint:
	 *     (name=ID (func+=Functions | vars+=Variables | conditional+=Conditionals | loops+=Loops | print+=Prints)*)
	 * </pre>
	 */
	protected void sequence_Operations(ISerializationContext context, Operations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Ors
	 *     BooleanFunction returns Ors
	 *     Ors returns Ors
	 *
	 * Constraint:
	 *     primary+=Primary+
	 * </pre>
	 */
	protected void sequence_Ors(ISerializationContext context, Ors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParametersOutptut returns ParametersOutptut
	 *
	 * Constraint:
	 *     (param=varParmArgs | (params+=varParmArgs params+=varParmArgs*))?
	 * </pre>
	 */
	protected void sequence_ParametersOutptut(ISerializationContext context, ParametersOutptut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parametersfunc returns funOutputs
	 *
	 * Constraint:
	 *     (params+=Expression params+=Expression*)?
	 * </pre>
	 */
	protected void sequence_Parametersfunc(ISerializationContext context, funOutputs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sum returns Primary
	 *     Sum.Sum_1_0 returns Primary
	 *     Subs returns Primary
	 *     Subs.Subs_1_0 returns Primary
	 *     Divition returns Primary
	 *     Divition.Divition_1_0 returns Primary
	 *     Multiplication returns Primary
	 *     Multiplication.Multiplication_1_0 returns Primary
	 *     Primary returns Primary
	 *
	 * Constraint:
	 *     var=[Variables|ID]
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Primary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.PRIMARY__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.PRIMARY__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getVarVariablesIDTerminalRuleCall_1_0_1(), semanticObject.eGet(LlmsPackage.Literals.PRIMARY__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Prints returns Prints
	 *
	 * Constraint:
	 *     (print+=ParmsPrint print+=ParmsPrint*)?
	 * </pre>
	 */
	protected void sequence_Prints(ISerializationContext context, Prints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParmsPrint returns Strings
	 *     Sum returns Strings
	 *     Sum.Sum_1_0 returns Strings
	 *     Subs returns Strings
	 *     Subs.Subs_1_0 returns Strings
	 *     Divition returns Strings
	 *     Divition.Divition_1_0 returns Strings
	 *     Multiplication returns Strings
	 *     Multiplication.Multiplication_1_0 returns Strings
	 *     Primary returns Strings
	 *     Data returns Strings
	 *     Strings returns Strings
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Strings(ISerializationContext context, Strings semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.STRINGS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.STRINGS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringsAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sum returns Subs
	 *     Sum.Sum_1_0 returns Subs
	 *     Subs returns Subs
	 *     Subs.Subs_1_0 returns Subs
	 *
	 * Constraint:
	 *     (left=Subs_Subs_1_0 right=Divition)
	 * </pre>
	 */
	protected void sequence_Subs(ISerializationContext context, Subs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.SUBS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.SUBS__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.SUBS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.SUBS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubsAccess().getSubsLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubsAccess().getRightDivitionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sum returns Sum
	 *     Sum.Sum_1_0 returns Sum
	 *
	 * Constraint:
	 *     (left=Sum_Sum_1_0 right=Subs)
	 * </pre>
	 */
	protected void sequence_Sum(ISerializationContext context, Sum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.SUM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.SUM__LEFT));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.SUM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.SUM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getSumLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumAccess().getRightSubsParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variables returns Variables
	 *
	 * Constraint:
	 *     ((typesVars=varParmArgs | typesVars=CallVariable) exp=Expression)
	 * </pre>
	 */
	protected void sequence_Variables(ISerializationContext context, Variables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParmsPrint returns callFunction
	 *     Sum returns callFunction
	 *     Sum.Sum_1_0 returns callFunction
	 *     Subs returns callFunction
	 *     Subs.Subs_1_0 returns callFunction
	 *     Divition returns callFunction
	 *     Divition.Divition_1_0 returns callFunction
	 *     Multiplication returns callFunction
	 *     Multiplication.Multiplication_1_0 returns callFunction
	 *     Primary returns callFunction
	 *     callFunction returns callFunction
	 *
	 * Constraint:
	 *     (func=[Functions|ID] (exp+=Expression exp+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_callFunction(ISerializationContext context, callFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sum returns varParmArgs
	 *     Sum.Sum_1_0 returns varParmArgs
	 *     Subs returns varParmArgs
	 *     Subs.Subs_1_0 returns varParmArgs
	 *     Divition returns varParmArgs
	 *     Divition.Divition_1_0 returns varParmArgs
	 *     Multiplication returns varParmArgs
	 *     Multiplication.Multiplication_1_0 returns varParmArgs
	 *     Primary returns varParmArgs
	 *     varParmArgs returns varParmArgs
	 *
	 * Constraint:
	 *     (name=ID dataType=DataTypes)
	 * </pre>
	 */
	protected void sequence_varParmArgs(ISerializationContext context, varParmArgs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.VAR_PARM_ARGS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.VAR_PARM_ARGS__NAME));
			if (transientValues.isValueTransient(semanticObject, LlmsPackage.Literals.VAR_PARM_ARGS__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LlmsPackage.Literals.VAR_PARM_ARGS__DATA_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarParmArgsAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarParmArgsAccess().getDataTypeDataTypesParserRuleCall_2_0(), semanticObject.getDataType());
		feeder.finish();
	}
	
	
}
