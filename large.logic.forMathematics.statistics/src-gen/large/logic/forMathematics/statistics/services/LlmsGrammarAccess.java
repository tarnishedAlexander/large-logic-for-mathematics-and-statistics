/*
 * generated by Xtext 2.35.0
 */
package large.logic.forMathematics.statistics.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LlmsGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class OperationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Operations");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOperationsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cFuncAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cFuncFunctionsParserRuleCall_4_0_0 = (RuleCall)cFuncAssignment_4_0.eContents().get(0);
		private final Assignment cVarsAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cVarsVarParmArgsParserRuleCall_4_1_0 = (RuleCall)cVarsAssignment_4_1.eContents().get(0);
		private final Assignment cConditionalAssignment_4_2 = (Assignment)cAlternatives_4.eContents().get(2);
		private final RuleCall cConditionalConditionalsParserRuleCall_4_2_0 = (RuleCall)cConditionalAssignment_4_2.eContents().get(0);
		private final Assignment cLoopsAssignment_4_3 = (Assignment)cAlternatives_4.eContents().get(3);
		private final RuleCall cLoopsLoopsParserRuleCall_4_3_0 = (RuleCall)cLoopsAssignment_4_3.eContents().get(0);
		private final Assignment cPrintAssignment_4_4 = (Assignment)cAlternatives_4.eContents().get(4);
		private final RuleCall cPrintPrintsParserRuleCall_4_4_0 = (RuleCall)cPrintAssignment_4_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Operations:
		//    {Operations} "Class"
		//    name=ID
		//     "{"
		//    (func += Functions |
		//    vars += varParmArgs |
		//    conditional+=Conditionals |
		//    loops+=Loops |
		//    print += Prints)*
		//    "}"
		//    ;
		@Override public ParserRule getRule() { return rule; }
		
		//{Operations} "Class"
		//name=ID
		// "{"
		//(func += Functions |
		//vars += varParmArgs |
		//conditional+=Conditionals |
		//loops+=Loops |
		//print += Prints)*
		//"}"
		public Group getGroup() { return cGroup; }
		
		//{Operations}
		public Action getOperationsAction_0() { return cOperationsAction_0; }
		
		//"Class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(func += Functions |
		//vars += varParmArgs |
		//conditional+=Conditionals |
		//loops+=Loops |
		//print += Prints)*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//func += Functions
		public Assignment getFuncAssignment_4_0() { return cFuncAssignment_4_0; }
		
		//Functions
		public RuleCall getFuncFunctionsParserRuleCall_4_0_0() { return cFuncFunctionsParserRuleCall_4_0_0; }
		
		//vars += varParmArgs
		public Assignment getVarsAssignment_4_1() { return cVarsAssignment_4_1; }
		
		//varParmArgs
		public RuleCall getVarsVarParmArgsParserRuleCall_4_1_0() { return cVarsVarParmArgsParserRuleCall_4_1_0; }
		
		//conditional+=Conditionals
		public Assignment getConditionalAssignment_4_2() { return cConditionalAssignment_4_2; }
		
		//Conditionals
		public RuleCall getConditionalConditionalsParserRuleCall_4_2_0() { return cConditionalConditionalsParserRuleCall_4_2_0; }
		
		//loops+=Loops
		public Assignment getLoopsAssignment_4_3() { return cLoopsAssignment_4_3; }
		
		//Loops
		public RuleCall getLoopsLoopsParserRuleCall_4_3_0() { return cLoopsLoopsParserRuleCall_4_3_0; }
		
		//print += Prints
		public Assignment getPrintAssignment_4_4() { return cPrintAssignment_4_4; }
		
		//Prints
		public RuleCall getPrintPrintsParserRuleCall_4_4_0() { return cPrintPrintsParserRuleCall_4_4_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class PrintsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Prints");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPrintsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPrintKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cPrintAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cPrintParmsPrintParserRuleCall_3_0_0 = (RuleCall)cPrintAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cPrintAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cPrintParmsPrintParserRuleCall_3_1_1_0 = (RuleCall)cPrintAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Prints:
		//    {Prints} "print" "("
		//    (print+=ParmsPrint ("," print+=ParmsPrint)*)?
		//    ")"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Prints} "print" "("
		//(print+=ParmsPrint ("," print+=ParmsPrint)*)?
		//")"
		public Group getGroup() { return cGroup; }
		
		//{Prints}
		public Action getPrintsAction_0() { return cPrintsAction_0; }
		
		//"print"
		public Keyword getPrintKeyword_1() { return cPrintKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(print+=ParmsPrint ("," print+=ParmsPrint)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//print+=ParmsPrint
		public Assignment getPrintAssignment_3_0() { return cPrintAssignment_3_0; }
		
		//ParmsPrint
		public RuleCall getPrintParmsPrintParserRuleCall_3_0_0() { return cPrintParmsPrintParserRuleCall_3_0_0; }
		
		//("," print+=ParmsPrint)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//print+=ParmsPrint
		public Assignment getPrintAssignment_3_1_1() { return cPrintAssignment_3_1_1; }
		
		//ParmsPrint
		public RuleCall getPrintParmsPrintParserRuleCall_3_1_1_0() { return cPrintParmsPrintParserRuleCall_3_1_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ParmsPrintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.ParmsPrint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDataParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCallVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCallFunctionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ParmsPrint:
		//    Data | CallVariable | callFunction
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Data | CallVariable | callFunction
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Data
		public RuleCall getDataParserRuleCall_0() { return cDataParserRuleCall_0; }
		
		//CallVariable
		public RuleCall getCallVariableParserRuleCall_1() { return cCallVariableParserRuleCall_1; }
		
		//callFunction
		public RuleCall getCallFunctionParserRuleCall_2() { return cCallFunctionParserRuleCall_2; }
	}
	public class NamesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Names");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Names:
		//    name = ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name = ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class FunctionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Functions");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOutputAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOutputParametersOutptutParserRuleCall_1_0 = (RuleCall)cOutputAssignment_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameNamesParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cParamsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cParamsParametersfuncParserRuleCall_4_0 = (RuleCall)cParamsAssignment_4.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBodyAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBodyBodiesParserRuleCall_7_0 = (RuleCall)cBodyAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Functions:
		//    "Function"
		//    output = ParametersOutptut
		//    "<="
		//    name = Names
		//    params = Parametersfunc
		//    "=>"
		//    "{"
		//    body = Bodies
		//    "}"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"Function"
		//output = ParametersOutptut
		//"<="
		//name = Names
		//params = Parametersfunc
		//"=>"
		//"{"
		//body = Bodies
		//"}"
		public Group getGroup() { return cGroup; }
		
		//"Function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }
		
		//output = ParametersOutptut
		public Assignment getOutputAssignment_1() { return cOutputAssignment_1; }
		
		//ParametersOutptut
		public RuleCall getOutputParametersOutptutParserRuleCall_1_0() { return cOutputParametersOutptutParserRuleCall_1_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_2() { return cLessThanSignEqualsSignKeyword_2; }
		
		//name = Names
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//Names
		public RuleCall getNameNamesParserRuleCall_3_0() { return cNameNamesParserRuleCall_3_0; }
		
		//params = Parametersfunc
		public Assignment getParamsAssignment_4() { return cParamsAssignment_4; }
		
		//Parametersfunc
		public RuleCall getParamsParametersfuncParserRuleCall_4_0() { return cParamsParametersfuncParserRuleCall_4_0; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_5() { return cEqualsSignGreaterThanSignKeyword_5; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }
		
		//body = Bodies
		public Assignment getBodyAssignment_7() { return cBodyAssignment_7; }
		
		//Bodies
		public RuleCall getBodyBodiesParserRuleCall_7_0() { return cBodyBodiesParserRuleCall_7_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}
	public class BodiesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Bodies");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBodiesAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarGenericVariableParserRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Function [Output1, Output2] <= id(n:int) => {
		////        body
		////}
		//Bodies:
		//    //en bodies simempre que hagamos algo con expresiones
		//    //se va a guardar en una variable si no es instruccion
		//    {Bodies}
		//    //exp += Expression*
		//    var += GenericVariable*
		//    ";"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////en bodies simempre que hagamos algo con expresiones
		////se va a guardar en una variable si no es instruccion
		//{Bodies}
		////exp += Expression*
		//var += GenericVariable*
		//";"
		public Group getGroup() { return cGroup; }
		
		////en bodies simempre que hagamos algo con expresiones
		////se va a guardar en una variable si no es instruccion
		//{Bodies}
		public Action getBodiesAction_0() { return cBodiesAction_0; }
		
		////exp += Expression*
		//var += GenericVariable*
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }
		
		//GenericVariable
		public RuleCall getVarGenericVariableParserRuleCall_1_0() { return cVarGenericVariableParserRuleCall_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class LoopsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Loops");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVarAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarGenericVariableParserRuleCall_2_0 = (RuleCall)cVarAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNumberAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNumberNumbersParserRuleCall_4_0 = (RuleCall)cNumberAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cEqualsSignGreaterThanSignKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cLeftCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cBodyAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBodyBodiesParserRuleCall_8_0 = (RuleCall)cBodyAssignment_8.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//Loops:
		//    "for"
		//    "("
		//    var=GenericVariable ":" number=Numbers
		//    ")"
		//    "=>"
		//    "{"
		//    body+=Bodies+
		//    "}"
		//    //falta while
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"for"
		//"("
		//var=GenericVariable ":" number=Numbers
		//")"
		//"=>"
		//"{"
		//body+=Bodies+
		//"}"
		public Group getGroup() { return cGroup; }
		
		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//var=GenericVariable
		public Assignment getVarAssignment_2() { return cVarAssignment_2; }
		
		//GenericVariable
		public RuleCall getVarGenericVariableParserRuleCall_2_0() { return cVarGenericVariableParserRuleCall_2_0; }
		
		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//number=Numbers
		public Assignment getNumberAssignment_4() { return cNumberAssignment_4; }
		
		//Numbers
		public RuleCall getNumberNumbersParserRuleCall_4_0() { return cNumberNumbersParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_6() { return cEqualsSignGreaterThanSignKeyword_6; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_7() { return cLeftCurlyBracketKeyword_7; }
		
		//body+=Bodies+
		public Assignment getBodyAssignment_8() { return cBodyAssignment_8; }
		
		//Bodies
		public RuleCall getBodyBodiesParserRuleCall_8_0() { return cBodyBodiesParserRuleCall_8_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class ConditionalsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Conditionals");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cLogicalParamsParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cEqualsSignGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBodyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyBodiesParserRuleCall_6_0 = (RuleCall)cBodyAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cElseIfKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Assignment cLogicParmsAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cLogicParmsLogicalParamsParserRuleCall_8_2_0 = (RuleCall)cLogicParmsAssignment_8_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8_3 = (Keyword)cGroup_8.eContents().get(3);
		private final Keyword cEqualsSignGreaterThanSignKeyword_8_4 = (Keyword)cGroup_8.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_8_5 = (Keyword)cGroup_8.eContents().get(5);
		private final Assignment cBodyAssignment_8_6 = (Assignment)cGroup_8.eContents().get(6);
		private final RuleCall cBodyBodiesParserRuleCall_8_6_0 = (RuleCall)cBodyAssignment_8_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8_7 = (Keyword)cGroup_8.eContents().get(7);
		private final Keyword cElseKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Assignment cBodyAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cBodyBodiesParserRuleCall_10_0 = (RuleCall)cBodyAssignment_10.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		//Conditionals:
		//    "if" "("
		//    LogicalParams
		//    ")"
		//    "=>"
		//    "{"
		//    body+=Bodies+
		//    "}"
		//    ("else-if"
		//    "("
		//    logicParms+=LogicalParams
		//    ")"
		//    "=>"
		//    "{"
		//    body+=Bodies+
		//    "}")*
		//    "else{"
		//    body+=Bodies+
		//    "}"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"if" "("
		//LogicalParams
		//")"
		//"=>"
		//"{"
		//body+=Bodies+
		//"}"
		//("else-if"
		//"("
		//logicParms+=LogicalParams
		//")"
		//"=>"
		//"{"
		//body+=Bodies+
		//"}")*
		//"else{"
		//body+=Bodies+
		//"}"
		public Group getGroup() { return cGroup; }
		
		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//LogicalParams
		public RuleCall getLogicalParamsParserRuleCall_2() { return cLogicalParamsParserRuleCall_2; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_4() { return cEqualsSignGreaterThanSignKeyword_4; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//body+=Bodies+
		public Assignment getBodyAssignment_6() { return cBodyAssignment_6; }
		
		//Bodies
		public RuleCall getBodyBodiesParserRuleCall_6_0() { return cBodyBodiesParserRuleCall_6_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
		
		//("else-if"
		//"("
		//logicParms+=LogicalParams
		//")"
		//"=>"
		//"{"
		//body+=Bodies+
		//"}")*
		public Group getGroup_8() { return cGroup_8; }
		
		//"else-if"
		public Keyword getElseIfKeyword_8_0() { return cElseIfKeyword_8_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_8_1() { return cLeftParenthesisKeyword_8_1; }
		
		//logicParms+=LogicalParams
		public Assignment getLogicParmsAssignment_8_2() { return cLogicParmsAssignment_8_2; }
		
		//LogicalParams
		public RuleCall getLogicParmsLogicalParamsParserRuleCall_8_2_0() { return cLogicParmsLogicalParamsParserRuleCall_8_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_8_3() { return cRightParenthesisKeyword_8_3; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_8_4() { return cEqualsSignGreaterThanSignKeyword_8_4; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_8_5() { return cLeftCurlyBracketKeyword_8_5; }
		
		//body+=Bodies+
		public Assignment getBodyAssignment_8_6() { return cBodyAssignment_8_6; }
		
		//Bodies
		public RuleCall getBodyBodiesParserRuleCall_8_6_0() { return cBodyBodiesParserRuleCall_8_6_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_8_7() { return cRightCurlyBracketKeyword_8_7; }
		
		//"else{"
		public Keyword getElseKeyword_9() { return cElseKeyword_9; }
		
		//body+=Bodies+
		public Assignment getBodyAssignment_10() { return cBodyAssignment_10; }
		
		//Bodies
		public RuleCall getBodyBodiesParserRuleCall_10_0() { return cBodyBodiesParserRuleCall_10_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_11() { return cRightCurlyBracketKeyword_11; }
	}
	public class LogicalParamsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.LogicalParams");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalOperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cBoolFuncAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cBoolFuncBooleanFunctionParserRuleCall_1_0_0 = (RuleCall)cBoolFuncAssignment_1_0.eContents().get(0);
		private final Assignment cLgicOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLgicOpLogicalOperationParserRuleCall_1_1_0 = (RuleCall)cLgicOpAssignment_1_1.eContents().get(0);
		
		//LogicalParams:
		//    LogicalOperation (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LogicalOperation (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*
		public Group getGroup() { return cGroup; }
		
		//LogicalOperation
		public RuleCall getLogicalOperationParserRuleCall_0() { return cLogicalOperationParserRuleCall_0; }
		
		//(boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*
		public Group getGroup_1() { return cGroup_1; }
		
		//boolFunc+=BooleanFunction
		public Assignment getBoolFuncAssignment_1_0() { return cBoolFuncAssignment_1_0; }
		
		//BooleanFunction
		public RuleCall getBoolFuncBooleanFunctionParserRuleCall_1_0_0() { return cBoolFuncBooleanFunctionParserRuleCall_1_0_0; }
		
		//lgicOp+=LogicalOperation
		public Assignment getLgicOpAssignment_1_1() { return cLgicOpAssignment_1_1; }
		
		//LogicalOperation
		public RuleCall getLgicOpLogicalOperationParserRuleCall_1_1_0() { return cLgicOpLogicalOperationParserRuleCall_1_1_0; }
	}
	public class ParametersOutptutElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.ParametersOutptut");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cParamAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cParamVarParmArgsParserRuleCall_0_0 = (RuleCall)cParamAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cParametersOutptutAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cParamsAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cParamsVarParmArgsParserRuleCall_1_2_0_0 = (RuleCall)cParamsAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cParamsVarParmArgsParserRuleCall_1_2_1_1_0 = (RuleCall)cParamsAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		////"estan mal los parentesis"
		///*Parameters:
		//    {Parameters} (param += Expression (',' param += Expression)*)?
		//;*/
		//ParametersOutptut:
		//    param = varParmArgs
		//    |
		//    "["
		//    {ParametersOutptut}
		//    (params += varParmArgs("," params += varParmArgs)*)?
		//    "]"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//param = varParmArgs
		//|
		//"["
		//{ParametersOutptut}
		//(params += varParmArgs("," params += varParmArgs)*)?
		//"]"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//param = varParmArgs
		public Assignment getParamAssignment_0() { return cParamAssignment_0; }
		
		//varParmArgs
		public RuleCall getParamVarParmArgsParserRuleCall_0_0() { return cParamVarParmArgsParserRuleCall_0_0; }
		
		//"["
		//{ParametersOutptut}
		//(params += varParmArgs("," params += varParmArgs)*)?
		//"]"
		public Group getGroup_1() { return cGroup_1; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//{ParametersOutptut}
		public Action getParametersOutptutAction_1_1() { return cParametersOutptutAction_1_1; }
		
		//(params += varParmArgs("," params += varParmArgs)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//params += varParmArgs
		public Assignment getParamsAssignment_1_2_0() { return cParamsAssignment_1_2_0; }
		
		//varParmArgs
		public RuleCall getParamsVarParmArgsParserRuleCall_1_2_0_0() { return cParamsVarParmArgsParserRuleCall_1_2_0_0; }
		
		//("," params += varParmArgs)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }
		
		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }
		
		//params += varParmArgs
		public Assignment getParamsAssignment_1_2_1_1() { return cParamsAssignment_1_2_1_1; }
		
		//varParmArgs
		public RuleCall getParamsVarParmArgsParserRuleCall_1_2_1_1_0() { return cParamsVarParmArgsParserRuleCall_1_2_1_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}
	public class ParametersfuncElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Parametersfunc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cFunOutputsAction_1 = (Action)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParamsExpressionParserRuleCall_2_0_0 = (RuleCall)cParamsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParamsExpressionParserRuleCall_2_1_1_0 = (RuleCall)cParamsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Parametersfunc:
		//    "("
		//    {funOutputs}
		//    (params += Expression("," params += Expression)*)?
		//    ")"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"("
		//{funOutputs}
		//(params += Expression("," params += Expression)*)?
		//")"
		public Group getGroup() { return cGroup; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//{funOutputs}
		public Action getFunOutputsAction_1() { return cFunOutputsAction_1; }
		
		//(params += Expression("," params += Expression)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//params += Expression
		public Assignment getParamsAssignment_2_0() { return cParamsAssignment_2_0; }
		
		//Expression
		public RuleCall getParamsExpressionParserRuleCall_2_0_0() { return cParamsExpressionParserRuleCall_2_0_0; }
		
		//("," params += Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//params += Expression
		public Assignment getParamsAssignment_2_1_1() { return cParamsAssignment_2_1_1; }
		
		//Expression
		public RuleCall getParamsExpressionParserRuleCall_2_1_1_0() { return cParamsExpressionParserRuleCall_2_1_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Expression");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOpOperationParserRuleCall_0 = (RuleCall)cOpAssignment.eContents().get(0);
		
		/////en Expression hay ambiguedad y en bodies
		//Expression:
		//    op = Operation
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//op = Operation
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//Operation
		public RuleCall getOpOperationParserRuleCall_0() { return cOpOperationParserRuleCall_0; }
	}
	public class OperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Operation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAritmeticOperationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLogicalOperationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanFunctionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Operation:
		//    AritmeticOperation | LogicalOperation | BooleanFunction
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//AritmeticOperation | LogicalOperation | BooleanFunction
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AritmeticOperation
		public RuleCall getAritmeticOperationParserRuleCall_0() { return cAritmeticOperationParserRuleCall_0; }
		
		//LogicalOperation
		public RuleCall getLogicalOperationParserRuleCall_1() { return cLogicalOperationParserRuleCall_1; }
		
		//BooleanFunction
		public RuleCall getBooleanFunctionParserRuleCall_2() { return cBooleanFunctionParserRuleCall_2; }
	}
	public class LogicalOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.LogicalOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLessThanParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGreaterThanParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEqualParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNotEqualParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLessOrEqualParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cGreaterOrEqualParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//LogicalOperation:
		//    LessThan | GreaterThan | Equal | NotEqual | LessOrEqual | GreaterOrEqual
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LessThan | GreaterThan | Equal | NotEqual | LessOrEqual | GreaterOrEqual
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LessThan
		public RuleCall getLessThanParserRuleCall_0() { return cLessThanParserRuleCall_0; }
		
		//GreaterThan
		public RuleCall getGreaterThanParserRuleCall_1() { return cGreaterThanParserRuleCall_1; }
		
		//Equal
		public RuleCall getEqualParserRuleCall_2() { return cEqualParserRuleCall_2; }
		
		//NotEqual
		public RuleCall getNotEqualParserRuleCall_3() { return cNotEqualParserRuleCall_3; }
		
		//LessOrEqual
		public RuleCall getLessOrEqualParserRuleCall_4() { return cLessOrEqualParserRuleCall_4; }
		
		//GreaterOrEqual
		public RuleCall getGreaterOrEqualParserRuleCall_5() { return cGreaterOrEqualParserRuleCall_5; }
	}
	public class LessThanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.LessThan");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftPrimaryParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//LessThan:
		//    "<" left=Primary right=Primary
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"<" left=Primary right=Primary
		public Group getGroup() { return cGroup; }
		
		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//left=Primary
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Primary
		public RuleCall getLeftPrimaryParserRuleCall_1_0() { return cLeftPrimaryParserRuleCall_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_2_0() { return cRightPrimaryParserRuleCall_2_0; }
	}
	public class GreaterThanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.GreaterThan");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftPrimaryParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//GreaterThan:
		//    ">" left=Primary right=Primary
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//">" left=Primary right=Primary
		public Group getGroup() { return cGroup; }
		
		//">"
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }
		
		//left=Primary
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Primary
		public RuleCall getLeftPrimaryParserRuleCall_1_0() { return cLeftPrimaryParserRuleCall_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_2_0() { return cRightPrimaryParserRuleCall_2_0; }
	}
	public class EqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Equal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftPrimaryParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//Equal:
		//    "=" left=Primary right=Primary
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"=" left=Primary right=Primary
		public Group getGroup() { return cGroup; }
		
		//"="
		public Keyword getEqualsSignKeyword_0() { return cEqualsSignKeyword_0; }
		
		//left=Primary
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Primary
		public RuleCall getLeftPrimaryParserRuleCall_1_0() { return cLeftPrimaryParserRuleCall_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_2_0() { return cRightPrimaryParserRuleCall_2_0; }
	}
	public class NotEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.NotEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftPrimaryParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//NotEqual:
		//    "!=" left=Primary right=Primary
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"!=" left=Primary right=Primary
		public Group getGroup() { return cGroup; }
		
		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_0() { return cExclamationMarkEqualsSignKeyword_0; }
		
		//left=Primary
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Primary
		public RuleCall getLeftPrimaryParserRuleCall_1_0() { return cLeftPrimaryParserRuleCall_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_2_0() { return cRightPrimaryParserRuleCall_2_0; }
	}
	public class LessOrEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.LessOrEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftPrimaryParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//LessOrEqual:
		//    "<=" left=Primary right=Primary
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"<=" left=Primary right=Primary
		public Group getGroup() { return cGroup; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_0() { return cLessThanSignEqualsSignKeyword_0; }
		
		//left=Primary
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Primary
		public RuleCall getLeftPrimaryParserRuleCall_1_0() { return cLeftPrimaryParserRuleCall_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_2_0() { return cRightPrimaryParserRuleCall_2_0; }
	}
	public class GreaterOrEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.GreaterOrEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftPrimaryParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//GreaterOrEqual:
		//    ">=" left=Primary right=Primary
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//">=" left=Primary right=Primary
		public Group getGroup() { return cGroup; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_0() { return cGreaterThanSignEqualsSignKeyword_0; }
		
		//left=Primary
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Primary
		public RuleCall getLeftPrimaryParserRuleCall_1_0() { return cLeftPrimaryParserRuleCall_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_2_0() { return cRightPrimaryParserRuleCall_2_0; }
	}
	public class BooleanFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.BooleanFunction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAndsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOrsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNotsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNorsParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNandsParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//BooleanFunction:
		//    Ands | Ors| Nots | Nors | Nands
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Ands | Ors| Nots | Nors | Nands
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Ands
		public RuleCall getAndsParserRuleCall_0() { return cAndsParserRuleCall_0; }
		
		//Ors
		public RuleCall getOrsParserRuleCall_1() { return cOrsParserRuleCall_1; }
		
		//Nots
		public RuleCall getNotsParserRuleCall_2() { return cNotsParserRuleCall_2; }
		
		//Nors
		public RuleCall getNorsParserRuleCall_3() { return cNorsParserRuleCall_3; }
		
		//Nands
		public RuleCall getNandsParserRuleCall_4() { return cNandsParserRuleCall_4; }
	}
	public class AndsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Ands");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAmpersandAmpersandKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrimaryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrimaryPrimaryParserRuleCall_1_0 = (RuleCall)cPrimaryAssignment_1.eContents().get(0);
		
		//Ands:
		//    "&&" primary+=Primary+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"&&" primary+=Primary+
		public Group getGroup() { return cGroup; }
		
		//"&&"
		public Keyword getAmpersandAmpersandKeyword_0() { return cAmpersandAmpersandKeyword_0; }
		
		//primary+=Primary+
		public Assignment getPrimaryAssignment_1() { return cPrimaryAssignment_1; }
		
		//Primary
		public RuleCall getPrimaryPrimaryParserRuleCall_1_0() { return cPrimaryPrimaryParserRuleCall_1_0; }
	}
	public class OrsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Ors");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrimaryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrimaryPrimaryParserRuleCall_1_0 = (RuleCall)cPrimaryAssignment_1.eContents().get(0);
		
		//Ors:
		//    "||" primary += Primary+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"||" primary += Primary+
		public Group getGroup() { return cGroup; }
		
		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_0() { return cVerticalLineVerticalLineKeyword_0; }
		
		//primary += Primary+
		public Assignment getPrimaryAssignment_1() { return cPrimaryAssignment_1; }
		
		//Primary
		public RuleCall getPrimaryPrimaryParserRuleCall_1_0() { return cPrimaryPrimaryParserRuleCall_1_0; }
	}
	public class NotsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Nots");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrimaryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrimaryPrimaryParserRuleCall_1_0 = (RuleCall)cPrimaryAssignment_1.eContents().get(0);
		
		//Nots:
		//    "!" primary+=Primary+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"!" primary+=Primary+
		public Group getGroup() { return cGroup; }
		
		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }
		
		//primary+=Primary+
		public Assignment getPrimaryAssignment_1() { return cPrimaryAssignment_1; }
		
		//Primary
		public RuleCall getPrimaryPrimaryParserRuleCall_1_0() { return cPrimaryPrimaryParserRuleCall_1_0; }
	}
	public class NorsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Nors");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrimaryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrimaryPrimaryParserRuleCall_1_0 = (RuleCall)cPrimaryAssignment_1.eContents().get(0);
		
		//Nors:
		//    "nor" primary += Primary+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"nor" primary += Primary+
		public Group getGroup() { return cGroup; }
		
		//"nor"
		public Keyword getNorKeyword_0() { return cNorKeyword_0; }
		
		//primary += Primary+
		public Assignment getPrimaryAssignment_1() { return cPrimaryAssignment_1; }
		
		//Primary
		public RuleCall getPrimaryPrimaryParserRuleCall_1_0() { return cPrimaryPrimaryParserRuleCall_1_0; }
	}
	public class NandsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Nands");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNandKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrimaryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrimaryPrimaryParserRuleCall_1_0 = (RuleCall)cPrimaryAssignment_1.eContents().get(0);
		
		//Nands:
		//    "nand" primary += Primary+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"nand" primary += Primary+
		public Group getGroup() { return cGroup; }
		
		//"nand"
		public Keyword getNandKeyword_0() { return cNandKeyword_0; }
		
		//primary += Primary+
		public Assignment getPrimaryAssignment_1() { return cPrimaryAssignment_1; }
		
		//Primary
		public RuleCall getPrimaryPrimaryParserRuleCall_1_0() { return cPrimaryPrimaryParserRuleCall_1_0; }
	}
	public class AritmeticOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.AritmeticOperation");
		private final Assignment cSumAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSumSumParserRuleCall_0 = (RuleCall)cSumAssignment.eContents().get(0);
		
		//AritmeticOperation:
		//    sum = Sum
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//sum = Sum
		public Assignment getSumAssignment() { return cSumAssignment; }
		
		//Sum
		public RuleCall getSumSumParserRuleCall_0() { return cSumSumParserRuleCall_0; }
	}
	public class SumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Sum");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSubsParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSumLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSubsParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Sum returns Expression:
		//    Subs({Sum.left = current} '+' right = Subs)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Subs({Sum.left = current} '+' right = Subs)*
		public Group getGroup() { return cGroup; }
		
		//Subs
		public RuleCall getSubsParserRuleCall_0() { return cSubsParserRuleCall_0; }
		
		//({Sum.left = current} '+' right = Subs)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Sum.left = current}
		public Action getSumLeftAction_1_0() { return cSumLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right = Subs
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Subs
		public RuleCall getRightSubsParserRuleCall_1_2_0() { return cRightSubsParserRuleCall_1_2_0; }
	}
	public class SubsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Subs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivitionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSubsLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivitionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Subs returns Expression:
		//    Divition({Subs.left = current} '-' right = Divition)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Divition({Subs.left = current} '-' right = Divition)*
		public Group getGroup() { return cGroup; }
		
		//Divition
		public RuleCall getDivitionParserRuleCall_0() { return cDivitionParserRuleCall_0; }
		
		//({Subs.left = current} '-' right = Divition)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Subs.left = current}
		public Action getSubsLeftAction_1_0() { return cSubsLeftAction_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//right = Divition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Divition
		public RuleCall getRightDivitionParserRuleCall_1_2_0() { return cRightDivitionParserRuleCall_1_2_0; }
	}
	public class DivitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Divition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivitionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Divition returns Expression:
		//    Multiplication({Divition.left = current} '/' right = Multiplication)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Multiplication({Divition.left = current} '/' right = Multiplication)*
		public Group getGroup() { return cGroup; }
		
		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }
		
		//({Divition.left = current} '/' right = Multiplication)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Divition.left = current}
		public Action getDivitionLeftAction_1_0() { return cDivitionLeftAction_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }
		
		//right = Multiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_2_0() { return cRightMultiplicationParserRuleCall_1_2_0; }
	}
	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns Expressions:
		//    Primary ({Multiplication.left = current} '*' right = Primary)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Multiplication.left = current} '*' right = Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Multiplication.left = current} '*' right = Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiplication.left = current}
		public Action getMultiplicationLeftAction_1_0() { return cMultiplicationLeftAction_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
		
		//right = Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVarParmArgsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCallVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCallFunctionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDataParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		////en primary hay ambiguedad, mas en especifico en callFunction
		//    Primary:
		//        varParmArgs | CallVariable | callFunction | Data //falta puede ser numero o string o bool o char
		//    ;
		@Override public ParserRule getRule() { return rule; }
		
		//varParmArgs | CallVariable | callFunction | Data
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//varParmArgs
		public RuleCall getVarParmArgsParserRuleCall_0() { return cVarParmArgsParserRuleCall_0; }
		
		//CallVariable
		public RuleCall getCallVariableParserRuleCall_1() { return cCallVariableParserRuleCall_1; }
		
		//callFunction
		public RuleCall getCallFunctionParserRuleCall_2() { return cCallFunctionParserRuleCall_2; }
		
		//Data
		public RuleCall getDataParserRuleCall_3() { return cDataParserRuleCall_3; }
	}
	public class CallFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.callFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFuncAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFuncFunctionsCrossReference_0_0 = (CrossReference)cFuncAssignment_0.eContents().get(0);
		private final RuleCall cFuncFunctionsIDTerminalRuleCall_0_0_1 = (RuleCall)cFuncFunctionsCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpExpressionParserRuleCall_2_0_0 = (RuleCall)cExpAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cExpAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_2_1_1_0 = (RuleCall)cExpAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////ahora no puede hacer operaciones dentro de los argumentos de callfunction solo se le pasa datos
		//callFunction:
		//    func = [Functions]
		//    "(" (exp+=Expression ("," exp+=Expression)*)? ")"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//func = [Functions]
		//"(" (exp+=Expression ("," exp+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }
		
		//func = [Functions]
		public Assignment getFuncAssignment_0() { return cFuncAssignment_0; }
		
		//[Functions]
		public CrossReference getFuncFunctionsCrossReference_0_0() { return cFuncFunctionsCrossReference_0_0; }
		
		//ID
		public RuleCall getFuncFunctionsIDTerminalRuleCall_0_0_1() { return cFuncFunctionsIDTerminalRuleCall_0_0_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(exp+=Expression ("," exp+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//exp+=Expression
		public Assignment getExpAssignment_2_0() { return cExpAssignment_2_0; }
		
		//Expression
		public RuleCall getExpExpressionParserRuleCall_2_0_0() { return cExpExpressionParserRuleCall_2_0_0; }
		
		//("," exp+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//exp+=Expression
		public Assignment getExpAssignment_2_1_1() { return cExpAssignment_2_1_1; }
		
		//Expression
		public RuleCall getExpExpressionParserRuleCall_2_1_1_0() { return cExpExpressionParserRuleCall_2_1_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVarsVarParmArgsCrossReference_0_0 = (CrossReference)cVarsAssignment_0.eContents().get(0);
		private final RuleCall cVarsVarParmArgsIDTerminalRuleCall_0_0_1 = (RuleCall)cVarsVarParmArgsCrossReference_0_0.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpExpressionParserRuleCall_2_0 = (RuleCall)cExpAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//    // ((data+=Data("," data+=Data)*)? | (vars+=[Variables](","vars+=[Variables])*)? )
		//    //no entiendo porque?
		////    Variables:
		////        (varParmArgs | CallVariable) //reasignar un valor
		////        "<="
		////        exp = Expression
		////        ";"
		////    ;
		//    Assignment:
		//        vars = [varParmArgs] '<=' exp = Expression ";"
		//    ;
		@Override public ParserRule getRule() { return rule; }
		
		//vars = [varParmArgs] '<=' exp = Expression ";"
		public Group getGroup() { return cGroup; }
		
		//vars = [varParmArgs]
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//[varParmArgs]
		public CrossReference getVarsVarParmArgsCrossReference_0_0() { return cVarsVarParmArgsCrossReference_0_0; }
		
		//ID
		public RuleCall getVarsVarParmArgsIDTerminalRuleCall_0_0_1() { return cVarsVarParmArgsIDTerminalRuleCall_0_0_1; }
		
		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_1() { return cLessThanSignEqualsSignKeyword_1; }
		
		//exp = Expression
		public Assignment getExpAssignment_2() { return cExpAssignment_2; }
		
		//Expression
		public RuleCall getExpExpressionParserRuleCall_2_0() { return cExpExpressionParserRuleCall_2_0; }
		
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class GenericVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.GenericVariable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCallVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVarParmArgsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GenericVariable:
		//    CallVariable | varParmArgs
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//CallVariable | varParmArgs
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CallVariable
		public RuleCall getCallVariableParserRuleCall_0() { return cCallVariableParserRuleCall_0; }
		
		//varParmArgs
		public RuleCall getVarParmArgsParserRuleCall_1() { return cVarParmArgsParserRuleCall_1; }
	}
	public class CallVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.CallVariable");
		private final Assignment cVarsAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cVarsVarParmArgsCrossReference_0 = (CrossReference)cVarsAssignment.eContents().get(0);
		private final RuleCall cVarsVarParmArgsIDTerminalRuleCall_0_1 = (RuleCall)cVarsVarParmArgsCrossReference_0.eContents().get(1);
		
		//CallVariable:
		//    vars=[varParmArgs]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//vars=[varParmArgs]
		public Assignment getVarsAssignment() { return cVarsAssignment; }
		
		//[varParmArgs]
		public CrossReference getVarsVarParmArgsCrossReference_0() { return cVarsVarParmArgsCrossReference_0; }
		
		//ID
		public RuleCall getVarsVarParmArgsIDTerminalRuleCall_0_1() { return cVarsVarParmArgsIDTerminalRuleCall_0_1; }
	}
	public class VarParmArgsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.varParmArgs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDataTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDataTypeDataTypesParserRuleCall_2_0 = (RuleCall)cDataTypeAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLessThanSignEqualsSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cExpAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_3_1_0 = (RuleCall)cExpAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		//varParmArgs:
		//    name=ID ":" dataType = DataTypes ('<=' exp = Expression ";")?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ":" dataType = DataTypes ('<=' exp = Expression ";")?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//dataType = DataTypes
		public Assignment getDataTypeAssignment_2() { return cDataTypeAssignment_2; }
		
		//DataTypes
		public RuleCall getDataTypeDataTypesParserRuleCall_2_0() { return cDataTypeDataTypesParserRuleCall_2_0; }
		
		//('<=' exp = Expression ";")?
		public Group getGroup_3() { return cGroup_3; }
		
		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_3_0() { return cLessThanSignEqualsSignKeyword_3_0; }
		
		//exp = Expression
		public Assignment getExpAssignment_3_1() { return cExpAssignment_3_1; }
		
		//Expression
		public RuleCall getExpExpressionParserRuleCall_3_1_0() { return cExpExpressionParserRuleCall_3_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_3_2() { return cSemicolonKeyword_3_2; }
	}
	public class DataTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.DataTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cIntKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBoolKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDoublesKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cStringKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		////cambiar a strings
		//DataTypes:
		//     "int" | "bool" | "doubles" | "string"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"int" | "bool" | "doubles" | "string"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"int"
		public Keyword getIntKeyword_0() { return cIntKeyword_0; }
		
		//"bool"
		public Keyword getBoolKeyword_1() { return cBoolKeyword_1; }
		
		//"doubles"
		public Keyword getDoublesKeyword_2() { return cDoublesKeyword_2; }
		
		//"string"
		public Keyword getStringKeyword_3() { return cStringKeyword_3; }
	}
	public class DataElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Data");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumbersParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleansParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDoublesParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Data:
		//    Numbers | Strings | Booleans | Doubles
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Numbers | Strings | Booleans | Doubles
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Numbers
		public RuleCall getNumbersParserRuleCall_0() { return cNumbersParserRuleCall_0; }
		
		//Strings
		public RuleCall getStringsParserRuleCall_1() { return cStringsParserRuleCall_1; }
		
		//Booleans
		public RuleCall getBooleansParserRuleCall_2() { return cBooleansParserRuleCall_2; }
		
		//Doubles
		public RuleCall getDoublesParserRuleCall_3() { return cDoublesParserRuleCall_3; }
	}
	public class NumbersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Numbers");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Numbers:
		//    value=INT
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class StringsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Strings");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Strings:
		//    value= STRING
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value= STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class BooleansElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Booleans");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_0 = (Keyword)cValueAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBooleansAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFalseKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//Booleans:
		//    value?='true' | {Booleans} 'false'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value?='true' | {Booleans} 'false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value?='true'
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_0() { return cValueTrueKeyword_0_0; }
		
		//{Booleans} 'false'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Booleans}
		public Action getBooleansAction_1_0() { return cBooleansAction_1_0; }
		
		//'false'
		public Keyword getFalseKeyword_1_1() { return cFalseKeyword_1_1; }
	}
	public class DoublesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.Doubles");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDOUBLETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Doubles:
		//    value=DOUBLE
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DOUBLE
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DOUBLE
		public RuleCall getValueDOUBLETerminalRuleCall_0() { return cValueDOUBLETerminalRuleCall_0; }
	}
	
	
	private final OperationsElements pOperations;
	private final PrintsElements pPrints;
	private final ParmsPrintElements pParmsPrint;
	private final NamesElements pNames;
	private final FunctionsElements pFunctions;
	private final BodiesElements pBodies;
	private final LoopsElements pLoops;
	private final ConditionalsElements pConditionals;
	private final LogicalParamsElements pLogicalParams;
	private final ParametersOutptutElements pParametersOutptut;
	private final ParametersfuncElements pParametersfunc;
	private final ExpressionElements pExpression;
	private final OperationElements pOperation;
	private final LogicalOperationElements pLogicalOperation;
	private final LessThanElements pLessThan;
	private final GreaterThanElements pGreaterThan;
	private final EqualElements pEqual;
	private final NotEqualElements pNotEqual;
	private final LessOrEqualElements pLessOrEqual;
	private final GreaterOrEqualElements pGreaterOrEqual;
	private final BooleanFunctionElements pBooleanFunction;
	private final AndsElements pAnds;
	private final OrsElements pOrs;
	private final NotsElements pNots;
	private final NorsElements pNors;
	private final NandsElements pNands;
	private final AritmeticOperationElements pAritmeticOperation;
	private final SumElements pSum;
	private final SubsElements pSubs;
	private final DivitionElements pDivition;
	private final MultiplicationElements pMultiplication;
	private final PrimaryElements pPrimary;
	private final CallFunctionElements pCallFunction;
	private final AssignmentElements pAssignment;
	private final GenericVariableElements pGenericVariable;
	private final CallVariableElements pCallVariable;
	private final VarParmArgsElements pVarParmArgs;
	private final DataTypesElements pDataTypes;
	private final DataElements pData;
	private final NumbersElements pNumbers;
	private final StringsElements pStrings;
	private final BooleansElements pBooleans;
	private final DoublesElements pDoubles;
	private final TerminalRule tDOUBLE;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LlmsGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pOperations = new OperationsElements();
		this.pPrints = new PrintsElements();
		this.pParmsPrint = new ParmsPrintElements();
		this.pNames = new NamesElements();
		this.pFunctions = new FunctionsElements();
		this.pBodies = new BodiesElements();
		this.pLoops = new LoopsElements();
		this.pConditionals = new ConditionalsElements();
		this.pLogicalParams = new LogicalParamsElements();
		this.pParametersOutptut = new ParametersOutptutElements();
		this.pParametersfunc = new ParametersfuncElements();
		this.pExpression = new ExpressionElements();
		this.pOperation = new OperationElements();
		this.pLogicalOperation = new LogicalOperationElements();
		this.pLessThan = new LessThanElements();
		this.pGreaterThan = new GreaterThanElements();
		this.pEqual = new EqualElements();
		this.pNotEqual = new NotEqualElements();
		this.pLessOrEqual = new LessOrEqualElements();
		this.pGreaterOrEqual = new GreaterOrEqualElements();
		this.pBooleanFunction = new BooleanFunctionElements();
		this.pAnds = new AndsElements();
		this.pOrs = new OrsElements();
		this.pNots = new NotsElements();
		this.pNors = new NorsElements();
		this.pNands = new NandsElements();
		this.pAritmeticOperation = new AritmeticOperationElements();
		this.pSum = new SumElements();
		this.pSubs = new SubsElements();
		this.pDivition = new DivitionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pPrimary = new PrimaryElements();
		this.pCallFunction = new CallFunctionElements();
		this.pAssignment = new AssignmentElements();
		this.pGenericVariable = new GenericVariableElements();
		this.pCallVariable = new CallVariableElements();
		this.pVarParmArgs = new VarParmArgsElements();
		this.pDataTypes = new DataTypesElements();
		this.pData = new DataElements();
		this.pNumbers = new NumbersElements();
		this.pStrings = new StringsElements();
		this.pBooleans = new BooleansElements();
		this.pDoubles = new DoublesElements();
		this.tDOUBLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "large.logic.forMathematics.statistics.Llms.DOUBLE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("large.logic.forMathematics.statistics.Llms".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Operations:
	//    {Operations} "Class"
	//    name=ID
	//     "{"
	//    (func += Functions |
	//    vars += varParmArgs |
	//    conditional+=Conditionals |
	//    loops+=Loops |
	//    print += Prints)*
	//    "}"
	//    ;
	public OperationsElements getOperationsAccess() {
		return pOperations;
	}
	
	public ParserRule getOperationsRule() {
		return getOperationsAccess().getRule();
	}
	
	//Prints:
	//    {Prints} "print" "("
	//    (print+=ParmsPrint ("," print+=ParmsPrint)*)?
	//    ")"
	//;
	public PrintsElements getPrintsAccess() {
		return pPrints;
	}
	
	public ParserRule getPrintsRule() {
		return getPrintsAccess().getRule();
	}
	
	//ParmsPrint:
	//    Data | CallVariable | callFunction
	//;
	public ParmsPrintElements getParmsPrintAccess() {
		return pParmsPrint;
	}
	
	public ParserRule getParmsPrintRule() {
		return getParmsPrintAccess().getRule();
	}
	
	//Names:
	//    name = ID
	//;
	public NamesElements getNamesAccess() {
		return pNames;
	}
	
	public ParserRule getNamesRule() {
		return getNamesAccess().getRule();
	}
	
	//Functions:
	//    "Function"
	//    output = ParametersOutptut
	//    "<="
	//    name = Names
	//    params = Parametersfunc
	//    "=>"
	//    "{"
	//    body = Bodies
	//    "}"
	//;
	public FunctionsElements getFunctionsAccess() {
		return pFunctions;
	}
	
	public ParserRule getFunctionsRule() {
		return getFunctionsAccess().getRule();
	}
	
	//// Function [Output1, Output2] <= id(n:int) => {
	////        body
	////}
	//Bodies:
	//    //en bodies simempre que hagamos algo con expresiones
	//    //se va a guardar en una variable si no es instruccion
	//    {Bodies}
	//    //exp += Expression*
	//    var += GenericVariable*
	//    ";"
	//;
	public BodiesElements getBodiesAccess() {
		return pBodies;
	}
	
	public ParserRule getBodiesRule() {
		return getBodiesAccess().getRule();
	}
	
	//Loops:
	//    "for"
	//    "("
	//    var=GenericVariable ":" number=Numbers
	//    ")"
	//    "=>"
	//    "{"
	//    body+=Bodies+
	//    "}"
	//    //falta while
	//;
	public LoopsElements getLoopsAccess() {
		return pLoops;
	}
	
	public ParserRule getLoopsRule() {
		return getLoopsAccess().getRule();
	}
	
	//Conditionals:
	//    "if" "("
	//    LogicalParams
	//    ")"
	//    "=>"
	//    "{"
	//    body+=Bodies+
	//    "}"
	//    ("else-if"
	//    "("
	//    logicParms+=LogicalParams
	//    ")"
	//    "=>"
	//    "{"
	//    body+=Bodies+
	//    "}")*
	//    "else{"
	//    body+=Bodies+
	//    "}"
	//;
	public ConditionalsElements getConditionalsAccess() {
		return pConditionals;
	}
	
	public ParserRule getConditionalsRule() {
		return getConditionalsAccess().getRule();
	}
	
	//LogicalParams:
	//    LogicalOperation (boolFunc+=BooleanFunction lgicOp+=LogicalOperation)*
	//;
	public LogicalParamsElements getLogicalParamsAccess() {
		return pLogicalParams;
	}
	
	public ParserRule getLogicalParamsRule() {
		return getLogicalParamsAccess().getRule();
	}
	
	////"estan mal los parentesis"
	///*Parameters:
	//    {Parameters} (param += Expression (',' param += Expression)*)?
	//;*/
	//ParametersOutptut:
	//    param = varParmArgs
	//    |
	//    "["
	//    {ParametersOutptut}
	//    (params += varParmArgs("," params += varParmArgs)*)?
	//    "]"
	//;
	public ParametersOutptutElements getParametersOutptutAccess() {
		return pParametersOutptut;
	}
	
	public ParserRule getParametersOutptutRule() {
		return getParametersOutptutAccess().getRule();
	}
	
	//Parametersfunc:
	//    "("
	//    {funOutputs}
	//    (params += Expression("," params += Expression)*)?
	//    ")"
	//;
	public ParametersfuncElements getParametersfuncAccess() {
		return pParametersfunc;
	}
	
	public ParserRule getParametersfuncRule() {
		return getParametersfuncAccess().getRule();
	}
	
	/////en Expression hay ambiguedad y en bodies
	//Expression:
	//    op = Operation
	//;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Operation:
	//    AritmeticOperation | LogicalOperation | BooleanFunction
	//;
	public OperationElements getOperationAccess() {
		return pOperation;
	}
	
	public ParserRule getOperationRule() {
		return getOperationAccess().getRule();
	}
	
	//LogicalOperation:
	//    LessThan | GreaterThan | Equal | NotEqual | LessOrEqual | GreaterOrEqual
	//;
	public LogicalOperationElements getLogicalOperationAccess() {
		return pLogicalOperation;
	}
	
	public ParserRule getLogicalOperationRule() {
		return getLogicalOperationAccess().getRule();
	}
	
	//LessThan:
	//    "<" left=Primary right=Primary
	//;
	public LessThanElements getLessThanAccess() {
		return pLessThan;
	}
	
	public ParserRule getLessThanRule() {
		return getLessThanAccess().getRule();
	}
	
	//GreaterThan:
	//    ">" left=Primary right=Primary
	//;
	public GreaterThanElements getGreaterThanAccess() {
		return pGreaterThan;
	}
	
	public ParserRule getGreaterThanRule() {
		return getGreaterThanAccess().getRule();
	}
	
	//Equal:
	//    "=" left=Primary right=Primary
	//;
	public EqualElements getEqualAccess() {
		return pEqual;
	}
	
	public ParserRule getEqualRule() {
		return getEqualAccess().getRule();
	}
	
	//NotEqual:
	//    "!=" left=Primary right=Primary
	//;
	public NotEqualElements getNotEqualAccess() {
		return pNotEqual;
	}
	
	public ParserRule getNotEqualRule() {
		return getNotEqualAccess().getRule();
	}
	
	//LessOrEqual:
	//    "<=" left=Primary right=Primary
	//;
	public LessOrEqualElements getLessOrEqualAccess() {
		return pLessOrEqual;
	}
	
	public ParserRule getLessOrEqualRule() {
		return getLessOrEqualAccess().getRule();
	}
	
	//GreaterOrEqual:
	//    ">=" left=Primary right=Primary
	//;
	public GreaterOrEqualElements getGreaterOrEqualAccess() {
		return pGreaterOrEqual;
	}
	
	public ParserRule getGreaterOrEqualRule() {
		return getGreaterOrEqualAccess().getRule();
	}
	
	//BooleanFunction:
	//    Ands | Ors| Nots | Nors | Nands
	//;
	public BooleanFunctionElements getBooleanFunctionAccess() {
		return pBooleanFunction;
	}
	
	public ParserRule getBooleanFunctionRule() {
		return getBooleanFunctionAccess().getRule();
	}
	
	//Ands:
	//    "&&" primary+=Primary+
	//;
	public AndsElements getAndsAccess() {
		return pAnds;
	}
	
	public ParserRule getAndsRule() {
		return getAndsAccess().getRule();
	}
	
	//Ors:
	//    "||" primary += Primary+
	//;
	public OrsElements getOrsAccess() {
		return pOrs;
	}
	
	public ParserRule getOrsRule() {
		return getOrsAccess().getRule();
	}
	
	//Nots:
	//    "!" primary+=Primary+
	//;
	public NotsElements getNotsAccess() {
		return pNots;
	}
	
	public ParserRule getNotsRule() {
		return getNotsAccess().getRule();
	}
	
	//Nors:
	//    "nor" primary += Primary+
	//;
	public NorsElements getNorsAccess() {
		return pNors;
	}
	
	public ParserRule getNorsRule() {
		return getNorsAccess().getRule();
	}
	
	//Nands:
	//    "nand" primary += Primary+
	//;
	public NandsElements getNandsAccess() {
		return pNands;
	}
	
	public ParserRule getNandsRule() {
		return getNandsAccess().getRule();
	}
	
	//AritmeticOperation:
	//    sum = Sum
	//;
	public AritmeticOperationElements getAritmeticOperationAccess() {
		return pAritmeticOperation;
	}
	
	public ParserRule getAritmeticOperationRule() {
		return getAritmeticOperationAccess().getRule();
	}
	
	//Sum returns Expression:
	//    Subs({Sum.left = current} '+' right = Subs)*
	//;
	public SumElements getSumAccess() {
		return pSum;
	}
	
	public ParserRule getSumRule() {
		return getSumAccess().getRule();
	}
	
	//Subs returns Expression:
	//    Divition({Subs.left = current} '-' right = Divition)*
	//;
	public SubsElements getSubsAccess() {
		return pSubs;
	}
	
	public ParserRule getSubsRule() {
		return getSubsAccess().getRule();
	}
	
	//Divition returns Expression:
	//    Multiplication({Divition.left = current} '/' right = Multiplication)*
	//;
	public DivitionElements getDivitionAccess() {
		return pDivition;
	}
	
	public ParserRule getDivitionRule() {
		return getDivitionAccess().getRule();
	}
	
	//Multiplication returns Expressions:
	//    Primary ({Multiplication.left = current} '*' right = Primary)*
	//;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}
	
	////en primary hay ambiguedad, mas en especifico en callFunction
	//    Primary:
	//        varParmArgs | CallVariable | callFunction | Data //falta puede ser numero o string o bool o char
	//    ;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	////ahora no puede hacer operaciones dentro de los argumentos de callfunction solo se le pasa datos
	//callFunction:
	//    func = [Functions]
	//    "(" (exp+=Expression ("," exp+=Expression)*)? ")"
	//;
	public CallFunctionElements getCallFunctionAccess() {
		return pCallFunction;
	}
	
	public ParserRule getCallFunctionRule() {
		return getCallFunctionAccess().getRule();
	}
	
	//    // ((data+=Data("," data+=Data)*)? | (vars+=[Variables](","vars+=[Variables])*)? )
	//    //no entiendo porque?
	////    Variables:
	////        (varParmArgs | CallVariable) //reasignar un valor
	////        "<="
	////        exp = Expression
	////        ";"
	////    ;
	//    Assignment:
	//        vars = [varParmArgs] '<=' exp = Expression ";"
	//    ;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//GenericVariable:
	//    CallVariable | varParmArgs
	//;
	public GenericVariableElements getGenericVariableAccess() {
		return pGenericVariable;
	}
	
	public ParserRule getGenericVariableRule() {
		return getGenericVariableAccess().getRule();
	}
	
	//CallVariable:
	//    vars=[varParmArgs]
	//;
	public CallVariableElements getCallVariableAccess() {
		return pCallVariable;
	}
	
	public ParserRule getCallVariableRule() {
		return getCallVariableAccess().getRule();
	}
	
	//varParmArgs:
	//    name=ID ":" dataType = DataTypes ('<=' exp = Expression ";")?
	//;
	public VarParmArgsElements getVarParmArgsAccess() {
		return pVarParmArgs;
	}
	
	public ParserRule getVarParmArgsRule() {
		return getVarParmArgsAccess().getRule();
	}
	
	////cambiar a strings
	//DataTypes:
	//     "int" | "bool" | "doubles" | "string"
	//;
	public DataTypesElements getDataTypesAccess() {
		return pDataTypes;
	}
	
	public ParserRule getDataTypesRule() {
		return getDataTypesAccess().getRule();
	}
	
	//Data:
	//    Numbers | Strings | Booleans | Doubles
	//;
	public DataElements getDataAccess() {
		return pData;
	}
	
	public ParserRule getDataRule() {
		return getDataAccess().getRule();
	}
	
	//Numbers:
	//    value=INT
	//;
	public NumbersElements getNumbersAccess() {
		return pNumbers;
	}
	
	public ParserRule getNumbersRule() {
		return getNumbersAccess().getRule();
	}
	
	//Strings:
	//    value= STRING
	//;
	public StringsElements getStringsAccess() {
		return pStrings;
	}
	
	public ParserRule getStringsRule() {
		return getStringsAccess().getRule();
	}
	
	//Booleans:
	//    value?='true' | {Booleans} 'false'
	//;
	public BooleansElements getBooleansAccess() {
		return pBooleans;
	}
	
	public ParserRule getBooleansRule() {
		return getBooleansAccess().getRule();
	}
	
	//Doubles:
	//    value=DOUBLE
	//;
	public DoublesElements getDoublesAccess() {
		return pDoubles;
	}
	
	public ParserRule getDoublesRule() {
		return getDoublesAccess().getRule();
	}
	
	//terminal DOUBLE:
	//    '0'..'9'+'.'('0'..'9')*
	//;
	public TerminalRule getDOUBLERule() {
		return tDOUBLE;
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
