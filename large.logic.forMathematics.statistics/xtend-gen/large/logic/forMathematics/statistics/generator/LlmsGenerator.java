/**
 * generated by Xtext 2.35.0
 */
package large.logic.forMathematics.statistics.generator;

import java.util.Arrays;
import large.logic.forMathematics.statistics.llms.Bodies;
import large.logic.forMathematics.statistics.llms.CallVariable;
import large.logic.forMathematics.statistics.llms.Conditionals;
import large.logic.forMathematics.statistics.llms.Functions;
import large.logic.forMathematics.statistics.llms.Loops;
import large.logic.forMathematics.statistics.llms.Names;
import large.logic.forMathematics.statistics.llms.Operations;
import large.logic.forMathematics.statistics.llms.ParametersOutptut;
import large.logic.forMathematics.statistics.llms.Prints;
import large.logic.forMathematics.statistics.llms.varParmArgs;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class LlmsGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _get = resource.getContents().get(0);
    final Operations program = ((Operations) _get);
    fsa.generateFile(program.getName(), ".m", this.generate(program));
  }

  public CharSequence generate(final Operations op) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<Functions> _func = op.getFunc();
      for(final Functions functions : _func) {
        CharSequence _generate = this.generate(functions);
        _builder.append(_generate);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    {
      EList<varParmArgs> _vars = op.getVars();
      for(final varParmArgs variables : _vars) {
        CharSequence _generate_1 = this.generate(variables);
        _builder.append(_generate_1);
        _builder.newLineIfNotEmpty();
      }
    }
    {
      EList<Conditionals> _conditional = op.getConditional();
      for(final Conditionals conditional : _conditional) {
        CharSequence _generate_2 = this.generate(conditional);
        _builder.append(_generate_2);
        _builder.newLineIfNotEmpty();
      }
    }
    {
      EList<Loops> _loops = op.getLoops();
      for(final Loops loops : _loops) {
        CharSequence _generate_3 = this.generate(loops);
        _builder.append(_generate_3);
        _builder.newLineIfNotEmpty();
      }
    }
    {
      EList<Prints> _print = op.getPrint();
      for(final Prints prints : _print) {
        CharSequence _generate_4 = this.generate(prints);
        _builder.append(_generate_4);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence generatefunc(final Functions fun) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("function ");
    ParametersOutptut _output = fun.getOutput();
    _builder.append(_output);
    _builder.append(" = ");
    Names _name = fun.getName();
    _builder.append(_name);
    _builder.append(" ");
    ParametersOutptut _output_1 = fun.getOutput();
    _builder.append(_output_1);
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    Bodies _body = fun.getBody();
    _builder.append(_body);
    _builder.newLineIfNotEmpty();
    _builder.append("end");
    _builder.newLine();
    return _builder;
  }

  public CharSequence generateVariables(final /* Variables */Object vars) {
    throw new Error("Unresolved compilation problems:"
      + "\nexp cannot be resolved");
  }

  protected CharSequence _generate(final varParmArgs vpa) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = vpa.getName();
    _builder.append(_name);
    _builder.append("  ");
    String _dataType = vpa.getDataType();
    _builder.append(_dataType);
    _builder.newLineIfNotEmpty();
    return _builder;
  }

  protected CharSequence _generate(final CallVariable cv) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder;
  }

  public CharSequence generate(final EObject cv) {
    if (cv instanceof CallVariable) {
      return _generate((CallVariable)cv);
    } else if (cv instanceof varParmArgs) {
      return _generate((varParmArgs)cv);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(cv).toString());
    }
  }
}
